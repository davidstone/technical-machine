// Copyright David Stone 2022.
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

#pragma once

#include <tm/ps_usage_stats/header.hpp>

#include <tm/generation.hpp>

#include <containers/array.hpp>
#include <containers/vector.hpp>

#include <bit>
#include <cstddef>
#include <span>
#include <string_view>

namespace technicalmachine {

inline auto string_to_bytes(std::string_view const str) {
	return containers::vector(std::span(
		reinterpret_cast<std::byte const *>(containers::data(str)),
		containers::size(str)
	));
}

constexpr auto cast_to_bytes(auto const value, auto const bytes) {
	return std::bit_cast<containers::array<std::byte, bytes>>(value);
}

inline auto no_items(Generation const generation) {
	static constexpr auto later_generation = containers::array{
		// One element
		std::byte(0x01),
		std::byte(0x00),
		// No item
		std::byte(0x00),
		std::byte(0x00),
		// 1.0
		std::byte(0x00),
		std::byte(0x00),
		std::byte(0x00),
		std::byte(0x00),
		std::byte(0x00),
		std::byte(0x00),
		std::byte(0xF0),
		std::byte(0x3F)
	};
	return generation >= Generation::two ? later_generation : std::span<std::byte const>();
}

inline auto no_abilities(Generation const generation) {
	static constexpr auto later_generation = containers::array{
		// 1 element
		std::byte(0x01),
		std::byte(0x00),
		// Honey Gather
		std::byte(0x75),
		std::byte(0x00),
		// 1.0
		std::byte(0x00),
		std::byte(0x00),
		std::byte(0x00),
		std::byte(0x00),
		std::byte(0x00),
		std::byte(0x00),
		std::byte(0xF0),
		std::byte(0x3F)
	};
	return generation >= Generation::three ? later_generation : std::span<std::byte const>();
}

// This is the smallest file generated by my generator. It's possible to make a
// smaller legal file.
inline auto smallest_team_bytes(Generation const generation) {
	return containers::concatenate<containers::vector<std::byte>>(
		string_to_bytes(usage_stats_magic_string),
		// Version
		cast_to_bytes(std::uint16_t(0), 2_bi),
		// Generation
		cast_to_bytes(std::uint8_t(generation), 1_bi),
		// Number of species
		cast_to_bytes(std::uint16_t(1), 2_bi),
		cast_to_bytes(Species::Mew, 2_bi),
		// Weight
		cast_to_bytes(1.0, 8_bi),
		// Speed count
		cast_to_bytes(std::uint16_t(1), 2_bi),
		// Speed value
		cast_to_bytes(std::uint16_t(7), 2_bi),
		// Speed weight
		cast_to_bytes(1.0, 8_bi),
		// Teammate count
		cast_to_bytes(std::uint16_t(0), 2_bi),
		// Moves count
		cast_to_bytes(std::uint16_t(1), 2_bi),
		cast_to_bytes(Moves::Cut, 2_bi),
		// Move weight
		cast_to_bytes(1.0, 8_bi),
		// Detailed stats, speed count
		cast_to_bytes(std::uint16_t(1), 2_bi),
		// Detailed stats, speed value
		cast_to_bytes(std::uint16_t(7), 2_bi),
		// Detailed stats, speed weight
		cast_to_bytes(1.0, 8_bi),
		// Detailed stats, teammates count
		cast_to_bytes(std::uint16_t(0), 2_bi),
		// Detailed stats, other moves count
		cast_to_bytes(std::uint16_t(0), 2_bi),
		no_items(generation),
		no_abilities(generation),
		no_items(generation),
		no_abilities(generation)
	);
}

} // namespace technicalmachine
